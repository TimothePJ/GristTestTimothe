<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Grist Two-Step Selection with Editable Table</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #2c2c2c;
        color: white;
      }

      .sticky-container {
        position: sticky;
        top: 0;
        background-color: #2c2c2c;
        padding: 20px;
        display: flex;
        align-items: flex-start;
        z-index: 1000;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
      }

      .dropdown-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-right: 20px;
      }

      label {
        font-weight: bold;
        margin-bottom: 10px;
      }

      select {
        width: 200px;
        padding: 8px;
        margin-bottom: 20px;
      }

      table {
        width: 100%;
        max-width: 800px;
        border-collapse: collapse;
        margin-top: 20px;
        background-color: #fff;
      }

      th, td {
        padding: 10px;
        border: 1px solid #ddd;
        text-align: left;
      }

      th {
        background-color: #333;
        color: white;
      }

      td {
        color: black;
      }

      .table-container {
        margin-top: 20px;
        padding: 20px;
      }

      .add-form {
        margin-top: 20px;
        padding: 10px;
        background-color: #f4f4f4;
        color: black;
      }

      .add-form input {
        margin-right: 10px;
        padding: 5px;
      }

      .add-form button {
        padding: 5px 10px;
        cursor: pointer;
      }

      /* Context Menu Styles */
      .context-menu {
        display: none;
        position: absolute;
        background-color: #333;
        color: white;
        border: 1px solid #ddd;
        z-index: 10000;
        padding: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      }

      .context-menu button {
        display: block;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        padding: 5px;
        width: 100%;
        text-align: left;
      }

      .context-menu button:hover {
        background-color: #444;
      }
    </style>
  </head>
  <body>
    <!-- Container for the sticky selection lists -->
    <div class="sticky-container">
      <!-- First dropdown for selecting a project -->
      <div class="dropdown-container">
        <label for="firstColumnDropdown">Projet :</label>
        <select id="firstColumnDropdown">
          <option value="">Select an option</option>
        </select>
      </div>

      <!-- Second dropdown for selecting the tableau -->
      <div class="dropdown-container">
        <label for="secondColumnListbox">Tableau :</label>
        <select id="secondColumnListbox">
          <option value="">Select an option</option>
          <option value="addTable">AJOUTER TABLEAU</option>
        </select>
        <input type="file" id="fileInputProject" style="display: none;" accept=".xls,.xlsx,.xlsm" multiple />
      </div>
    </div>

    <!-- Table to display and edit the data -->
    <div class="table-container">
      <table id="dataTable">
        <thead>
          <tr id="tableHeader">
            <th>ID</th> <!-- Add a column for ID -->
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
      <button id="deleteOption">Supprimer</button>
    </div>

    <!-- Context Menu pour les projets -->
    <div id="projectContextMenu" class="context-menu">
      <button id="deleteProjectOption">Supprimer</button>
    </div>

    <!-- Form to add new rows -->
    <div class="add-form">
      <button id="addRowButton">Ajouter une ligne</button>
      <button id="saveButton">Sauvegarder</button>
      <button id="insertButton">Insérer</button>

      <input type="file" id="fileInput" style="display: none;" multiple>
    </div>

    <script>
      let records = [];
      let selectedFirstValue = '';
      let selectedSecondValue = '';
      let selectedRecordId = null;

      const projectDropdown = document.getElementById("firstColumnDropdown");
      const projectContextMenu = document.getElementById("projectContextMenu");

      let selectedProjectForContextMenu = null;

      // Ready Grist
      grist.ready();

      // Fonction pour peupler la première liste déroulante avec des valeurs uniques de la première colonne
      function populateFirstColumnDropdown(values) {
        const dropdown = document.getElementById("firstColumnDropdown");
      
        // Conserve la sélection actuelle
        const currentSelection = dropdown.value;
      
        dropdown.innerHTML = '<option value="">Select an option</option>'; // Réinitialise la liste déroulante
      
        values.sort().forEach((value) => {
          if (value) {
            const option = document.createElement("option");
            option.value = value;
            option.text = value;
            dropdown.appendChild(option);
          }
        });
      
        // Ajoute l'option "Ajouter Projet"
        const addProjectOption = document.createElement("option");
        addProjectOption.value = "Ajouter Projet";
        addProjectOption.text = "Ajouter Projet";
        dropdown.appendChild(addProjectOption);
      
        // Ajoute l'option "Insérer Projet"
        const insertProjectOption = document.createElement("option");
        insertProjectOption.value = "Insérer Projet";
        insertProjectOption.text = "Insérer Projet";
        dropdown.appendChild(insertProjectOption);
      
        // Restaure la sélection précédente si elle est encore présente
        dropdown.value = currentSelection || ""; // Conserve l'option sélectionnée ou reste sur "Select an option"
      }

      // Écouteur d'événement pour mettre à jour la valeur sélectionnée dans la première liste
      document.getElementById("firstColumnDropdown").addEventListener("change", function () {
        const selectedValue = this.value;
      
        if (selectedValue === "Ajouter Projet") {
          handleAddProject(); // Logique d'ajout d'un projet
        } else if (selectedValue === "Insérer Projet") {
          // Ouvre l'explorateur de fichiers
          document.getElementById("fileInputProject").click();
          // Réinitialise la sélection de la liste déroulante après avoir ouvert l'explorateur
          this.value = ""; 
        } else {
          selectedFirstValue = selectedValue;
          populateSecondColumnListbox(selectedFirstValue); // Actualise la deuxième liste
        }
      });

      // Function to populate the second dropdown based on the selected first column value
      function populateSecondColumnListbox(selectedValue) {
        const listbox = document.getElementById('secondColumnListbox');
        listbox.innerHTML = '<option value="">Select an option</option>'; // Réinitialise la liste
      
        const secondColumnValues = records
          .filter(record => record.NomProjet === selectedValue) // Filtre selon le projet
          .map(record => record.NomEtage) // Extrait les valeurs
          .filter((value, index, self) => value && self.indexOf(value) === index) // Supprime les doublons
          .sort();
      
        secondColumnValues.forEach(value => {
          const option = document.createElement('option');
          option.value = value;
          option.text = value;
          listbox.appendChild(option);
        });
      
        // Ajoute l'option "Ajouter Tableau"
        const addOption = document.createElement('option');
        addOption.value = 'addTable';
        addOption.text = 'Ajouter Tableau';
        listbox.appendChild(addOption);
      }

      // Function to populate the table based on the selected first and second column values
      function populateTable() {
        const selections = getCurrentSelections();
        if (!selections) return;
      
        const { selectedProject, selectedTable } = selections;
        const tableBody = document.getElementById('tableBody');
        const tableHeader = document.getElementById('tableHeader');
        
        tableBody.innerHTML = '';
        const filteredRecords = records.filter(
          (record) =>
            record.NomProjet === selectedProject && record.NomEtage === selectedTable
        );
      
        if (filteredRecords.length === 0) return;
      
        const exampleRecord = filteredRecords[0];
        const headers = Object.keys(exampleRecord).filter(
          (key) => key !== 'NomProjet' && key !== 'NomEtage' && key !== 'ID_Ligne'
        );
      
        tableHeader.innerHTML = '<th>ID</th>';
        headers.forEach((header) => {
          const th = document.createElement('th');
          th.textContent = header;
          tableHeader.appendChild(th);
        });
      
        filteredRecords.forEach((record) => {
          const tr = document.createElement('tr');
          tr.addEventListener('contextmenu', (event) => showContextMenu(event, record.ID_Ligne));
      
          const idCell = document.createElement('td');
          idCell.textContent = record.ID_Ligne;
          tr.appendChild(idCell);
      
          headers.forEach((header) => {
            const td = document.createElement('td');
            td.contentEditable = true;
            td.textContent = record[header] || '';
            tr.appendChild(td);
          });
      
          tableBody.appendChild(tr);
        });
      }

      // Show context menu on right-click and get the record ID from the first column
      function showContextMenu(event, recordId) {
        event.preventDefault();
        selectedRecordId = recordId;  // Store the ID of the selected record

        const contextMenu = document.getElementById('contextMenu');
        contextMenu.style.display = 'block';
        contextMenu.style.left = `${event.pageX}px`;
        contextMenu.style.top = `${event.pageY}px`;
      }

      // Hide context menu if clicked elsewhere
      document.addEventListener('click', function(event) {
        const contextMenu = document.getElementById('contextMenu');
        if (!contextMenu.contains(event.target)) {
          contextMenu.style.display = 'none';
        }
      });

      // Add event listener for "Supprimer" option
      document.getElementById('deleteOption').addEventListener('click', () => {
          console.log("Supprimer clicked for row ID:", selectedRecordId);
          
          // Supprime la ligne dans Grist
          grist.docApi.applyUserActions([['RemoveRecord', 'Fusion', Number(selectedRecordId)]])
          .then(() => {
              // Supprime la ligne localement dans le tableau
              records = records.filter(record => record.ID_Ligne !== selectedRecordId);
      
              // Actualise l'affichage du tableau
              populateTable();
      
              // Masquer le menu contextuel après la suppression
              hideContextMenu();
      
              console.log("Tableau actualisé et menu contextuel masqué après suppression.");
          })
          .catch(error => {
              console.error("Erreur lors de la suppression de la ligne dans Grist:", error);
              alert("Une erreur s'est produite lors de la suppression de la ligne.");
          });
      });

      // Fonction pour cacher le menu contextuel
      function hideContextMenu() {
          const contextMenu = document.getElementById('contextMenu');
          contextMenu.style.display = 'none';
      }

      // Fetch records from Grist
      grist.onRecords(function(receivedRecords) {
        console.log("Records received from Grist:", receivedRecords);
        
        records = receivedRecords.map(record => ({
          NomProjet: record.NomProjet || '',
          NomEtage: record.NomEtage || '',
          Emetteur: record.Emetteur || '',
          Reference: record.Reference || '',
          Indice: record.Indice || '',
          Recu: record.Recu || '',
          DescriptionObservations: record.DescriptionObservations || '',
          ID_Ligne: record.ID_Ligne || ''
        }));

        // Populate the first dropdown with unique values from 'NomProjet'
        const uniqueFirstColumnValues = [...new Set(records.map(record => record.NomProjet))];
        populateFirstColumnDropdown(uniqueFirstColumnValues);
      });

      // Listen to changes in the first dropdown and update the second listbox accordingly
      document.getElementById('firstColumnDropdown').addEventListener('change', function () {
        const selectedValue = this.value;
      
        if (selectedValue === "Ajouter Projet") {
          handleAddProject(); // Appelle la fonction pour ajouter un projet
        } else {
          selectedFirstValue = selectedValue;
          populateSecondColumnListbox(selectedFirstValue); // Actualise la deuxième liste
        }
      });

      // Listen to changes in the second dropdown and update the table accordingly
      document.getElementById('secondColumnListbox').addEventListener('change', function () {
        const selectedValue = this.value;
        if (selectedValue === 'addTable') {
          handleAddTable(); // Permet d'ajouter un tableau
        } else {
          selectedSecondValue = selectedValue; // Met à jour la valeur sélectionnée
          populateTable(); // Actualise le tableau HTML
        }
      });
      
      // Fonction pour ajouter un projet
      function handleAddProject() {
        if (window.isAddingProject) return; // Empêche les exécutions multiples
        window.isAddingProject = true; // Flag pour éviter les appels successifs
      
        const projectName = prompt("Entrez le nom du nouveau projet :");
        if (!projectName || projectName.trim() === "") {
          alert("Le nom du projet ne peut pas être vide.");
          window.isAddingProject = false; // Libère le flag
          return;
        }
      
        const firstTableName = prompt("Entrez le nom du premier tableau pour ce projet :");
        if (!firstTableName || firstTableName.trim() === "") {
          alert("Le nom du tableau ne peut pas être vide.");
          window.isAddingProject = false; // Libère le flag
          return;
        }
      
        // Génère un nouvel ID_Ligne unique
        const maxIdLigne = records.reduce((max, record) => {
          const idLigne = parseInt(record.ID_Ligne, 10);
          return idLigne > max ? idLigne : max;
        }, 0);
      
        const newIdLigne = maxIdLigne + 1;
      
        // Crée une nouvelle ligne pour le projet et son premier tableau
        const newRow = {
          NomProjet: projectName,
          NomEtage: firstTableName,
          Emetteur: "",
          Reference: "",
          Indice: "",
          Recu: "",
          DescriptionObservations: "",
          ID_Ligne: newIdLigne.toString(),
        };
      
        grist.docApi
          .applyUserActions([["AddRecord", "Fusion", null, newRow]])
          .then(() => {
            console.log("Nouveau projet ajouté :", newRow);
      
            // Actualise immédiatement les données locales
            records.push(newRow);
      
            // Met à jour la première liste déroulante
            const projectDropdown = document.getElementById("firstColumnDropdown");
            const uniqueProjects = records
              .map((record) => record.NomProjet)
              .filter((value, index, self) => value && self.indexOf(value) === index)
              .sort();
      
            projectDropdown.innerHTML = '<option value="">Select an option</option>';
            uniqueProjects.forEach((project) => {
              const option = document.createElement("option");
              option.value = project;
              option.text = project;
              projectDropdown.appendChild(option);
            });
      
            // Ajoute l'option "Ajouter Projet"
            const addProjectOption = document.createElement("option");
            addProjectOption.value = "Ajouter Projet";
            addProjectOption.text = "Ajouter Projet";
            projectDropdown.appendChild(addProjectOption);
      
            // Sélectionne automatiquement le projet ajouté
            projectDropdown.value = projectName;
            selectedFirstValue = projectName;
      
            // Met à jour la deuxième liste déroulante pour ce projet
            const secondColumnListbox = document.getElementById("secondColumnListbox");
            const tablesForProject = records
              .filter((record) => record.NomProjet === projectName)
              .map((record) => record.NomEtage)
              .filter((value, index, self) => value && self.indexOf(value) === index)
              .sort();
      
            secondColumnListbox.innerHTML = '<option value="">Select an option</option>';
            tablesForProject.forEach((table) => {
              const option = document.createElement("option");
              option.value = table;
              option.text = table;
              secondColumnListbox.appendChild(option);
            });
      
            // Ajoute l'option "Ajouter Tableau"
            const addTableOption = document.createElement("option");
            addTableOption.value = "addTable";
            addTableOption.text = "Ajouter Tableau";
            secondColumnListbox.appendChild(addTableOption);
      
            // Sélectionne automatiquement le tableau ajouté
            secondColumnListbox.value = firstTableName;
            selectedSecondValue = firstTableName;
      
            console.log(`Le projet "${projectName}" et son tableau "${firstTableName}" sont maintenant sélectionnés.`);
      
            // Affiche directement le tableau dans la vue HTML
            populateTable();
          })
          .catch((error) => {
            console.error("Erreur lors de l'ajout du projet :", error);
            alert("Erreur lors de l'ajout du projet.");
          })
          .finally(() => {
            window.isAddingProject = false; // Libère le flag
          });
      }

      // Fonction pour gérer l'ajout d'un tableau
      function handleAddTable() {
        if (window.isAddingTable) return; // Empêche les exécutions multiples
        window.isAddingTable = true; // Flag pour bloquer les appels successifs
      
        const newTableName = prompt("Entrez le nom du nouveau tableau :");
      
        if (!newTableName || newTableName.trim() === "") {
          alert("Le nom du tableau ne peut pas être vide.");
          window.isAddingTable = false; // Libère le flag
          return;
        }
      
        const selectedProject = selectedFirstValue.trim();
      
        if (!selectedProject) {
          alert("Veuillez sélectionner un projet avant d'ajouter un tableau.");
          window.isAddingTable = false; // Libère le flag
          return;
        }
      
        // Génère un nouvel ID_Ligne unique
        const maxIdLigne = records.reduce((max, record) => {
          const idLigne = parseInt(record.ID_Ligne, 10);
          return idLigne > max ? idLigne : max;
        }, 0);
      
        const newIdLigne = maxIdLigne + 1;
      
        // Crée une nouvelle ligne pour le tableau
        const newRow = {
          NomProjet: selectedProject,
          NomEtage: newTableName,
          Emetteur: "",
          Reference: "",
          Indice: "",
          Recu: "",
          DescriptionObservations: "",
          ID_Ligne: newIdLigne.toString(),
        };
      
        // Ajoute la nouvelle ligne dans Grist
        grist.docApi
          .applyUserActions([["AddRecord", "Fusion", null, newRow]])
          .then(() => {
            console.log("Nouveau tableau ajouté :", newRow);
      
            // Actualise immédiatement les données locales
            records.push(newRow);
      
            // Met à jour la deuxième liste déroulante
            const secondColumnListbox = document.getElementById("secondColumnListbox");
            const tablesForProject = records
              .filter((record) => record.NomProjet === selectedProject)
              .map((record) => record.NomEtage)
              .filter((value, index, self) => value && self.indexOf(value) === index)
              .sort();
      
            secondColumnListbox.innerHTML = '<option value="">Select an option</option>';
            tablesForProject.forEach((table) => {
              const option = document.createElement("option");
              option.value = table;
              option.text = table;
              secondColumnListbox.appendChild(option);
            });
      
            // Ajoute l'option "Ajouter Tableau"
            const addTableOption = document.createElement("option");
            addTableOption.value = "addTable";
            addTableOption.text = "Ajouter Tableau";
            secondColumnListbox.appendChild(addTableOption);
      
            // Sélectionne automatiquement le tableau ajouté
            secondColumnListbox.value = newTableName;
            selectedSecondValue = newTableName;
      
            console.log(`Le tableau "${newTableName}" est maintenant sélectionné.`);
      
            // Affiche directement le tableau dans la vue HTML
            populateTable();
          })
          .catch((error) => {
            console.error("Erreur lors de l'ajout du tableau :", error);
            alert("Erreur lors de l'ajout du tableau.");
          })
          .finally(() => {
            window.isAddingTable = false; // Libère le flag après le processus
          });
      }


      // Fonction pour ajouter une nouvelle ligne dans Grist
      function addRowToGrist() {
        if (!selectedFirstValue || !selectedSecondValue) {
          alert("Veuillez sélectionner un projet et un tableau.");
          return;
        }
      
        // Trouve la valeur la plus élevée d'ID_Ligne dans records
        const maxIdLigne = records.reduce((max, record) => {
          const idLigne = parseInt(record.ID_Ligne, 10);
          return idLigne > max ? idLigne : max;
        }, 0);
      
        // Définit une nouvelle valeur pour ID_Ligne en l'incrémentant de 1
        const newIdLigne = maxIdLigne + 1;
      
        // Création de la nouvelle ligne avec la valeur de ID_Ligne
        const newRow = {
          NomProjet: selectedFirstValue,
          NomEtage: selectedSecondValue,
          Emetteur: '',
          Reference: '',
          Indice: '',
          Recu: '',
          DescriptionObservations: '',
          ID_Ligne: newIdLigne.toString() // Convertit en string pour s'aligner avec les autres valeurs
        };
      
        // Envoie la requête pour ajouter la nouvelle ligne dans Grist
        grist.docApi.applyUserActions([
          ['AddRecord', 'Fusion', null, newRow]  // Utilise null pour l'ID, Grist s'en chargera
        ])
        .then(() => {
          console.log("Nouvelle ligne ajoutée :", newRow);
          // Actualise les données pour inclure la nouvelle ligne ajoutée
          records.push(newRow); // Mise à jour locale
          populateTable(); // Actualise l'affichage du tableau HTML
        })
        .catch(error => {
          console.error("Erreur lors de l'ajout de la ligne :", error);
          alert("Erreur lors de l'ajout de la ligne.");
        });
      }
      
      // Écouteur d'événement pour le bouton d'ajout
      document.getElementById('addRowButton').addEventListener('click', addRowToGrist);

      function getCurrentSelections(skipValidation = false) {
        const projectDropdown = document.getElementById('firstColumnDropdown');
        const tableDropdown = document.getElementById('secondColumnListbox');
      
        const selectedProject = projectDropdown.value.trim();
        const selectedTable = tableDropdown.value.trim();
      
        if (!selectedProject || (!selectedTable && !skipValidation)) {
          if (!skipValidation) {
            alert("Veuillez sélectionner un projet et un tableau.");
          }
          return null; // Retourne null si les sélections sont invalides
        }
      
        return { selectedProject, selectedTable };
      }

      // Fonction de sauvegarde mise à jour
      async function saveChanges() {
        // Obtenez les sélections actuelles
        const selections = getCurrentSelections();
        if (!selections) return; // Interrompt la fonction si les sélections sont invalides
      
        const { selectedProject, selectedTable } = selections;
      
        console.log(`Sauvegarde en cours pour le tableau "${selectedTable}" du projet "${selectedProject}".`);
      
        // Récupère les lignes du tableau HTML
        const tableBody = document.getElementById('tableBody');
        const rows = tableBody.getElementsByTagName('tr');
      
        const columnMap = ['Emetteur', 'Reference', 'Indice', 'Recu', 'DescriptionObservations'];
        const updates = [];
      
        for (const row of rows) {
          const cells = row.getElementsByTagName('td');
          const rowId = cells[0].textContent.trim(); // ID_Ligne
      
          // Recherche la ligne correspondante dans `records`
          const record = records.find(
            (rec) =>
              rec.ID_Ligne === rowId &&
              rec.NomProjet === selectedProject &&
              rec.NomEtage === selectedTable
          );
      
          if (!record) {
            console.warn(`Ligne introuvable pour ID_Ligne = ${rowId}, Projet = ${selectedProject}, Tableau = ${selectedTable}`);
            continue;
          }
      
          const updatedFields = {};
          let hasChanges = false;
      
          // Compare chaque champ
          for (let i = 1; i < cells.length; i++) {
            const fieldName = columnMap[i - 1];
            const cellValue = cells[i].textContent.trim();
      
            if (record[fieldName] !== cellValue) {
              updatedFields[fieldName] = cellValue;
              hasChanges = true;
            }
          }
      
          if (hasChanges) {
            updates.push(['UpdateRecord', 'Fusion', Number(rowId), updatedFields]);
          }
        }
      
        if (updates.length > 0) {
          try {
            await grist.docApi.applyUserActions(updates);
            console.log("Modifications sauvegardées avec succès :", updates);
            alert("Les modifications ont été sauvegardées.");
          } catch (error) {
            console.error("Erreur lors de la sauvegarde :", error);
            alert("Erreur lors de la sauvegarde.");
          }
        } else {
          alert("Aucune modification détectée pour la sauvegarde.");
        }
      }

      // Écouteur d'événement pour le bouton de sauvegarde
      document.getElementById('saveButton').addEventListener('click', saveChanges);

      // Écouteur d'événement pour le bouton d'insersion
      document.getElementById('insertButton').addEventListener('click', () => {
        document.getElementById('fileInput').click();
      });
    
      // Fonction pour ajouter une nouvelle ligne dans Grist avec le nom de fichier dans "Reference"
      function addRowWithFileName(fileName) {
        if (!selectedFirstValue || !selectedSecondValue) {
          alert("Veuillez sélectionner un projet et un tableau.");
          return;
        }
      
        // Enlève l'extension du fichier (partie après le dernier point)
        const fileNameWithoutExtension = fileName.split('.').slice(0, -1).join('.');
      
        // Trouve la valeur la plus élevée d'ID_Ligne dans records
        const maxIdLigne = records.reduce((max, record) => {
          const idLigne = parseInt(record.ID_Ligne, 10);
          return idLigne > max ? idLigne : max;
        }, 0);
      
        // Définit une nouvelle valeur pour ID_Ligne en l'incrémentant de 1
        const newIdLigne = maxIdLigne + 1;
      
        // Création de la nouvelle ligne avec la valeur de ID_Ligne et le nom du fichier sans extension pour "Reference"
        const newRow = {
          NomProjet: selectedFirstValue,
          NomEtage: selectedSecondValue,
          Emetteur: '',
          Reference: fileNameWithoutExtension, // Nom du fichier sans extension
          Indice: '',
          Recu: '',
          DescriptionObservations: '',
          ID_Ligne: newIdLigne.toString() // Convertit en string pour s'aligner avec les autres valeurs
        };
      
        // Envoie la requête pour ajouter la nouvelle ligne dans Grist
        grist.docApi.applyUserActions([
          ['AddRecord', 'Fusion', null, newRow]
        ])
        .then(() => {
          console.log("Nouvelle ligne ajoutée avec le fichier :", newRow);
          // Actualise les données pour inclure la nouvelle ligne ajoutée
          records.push(newRow); // Mise à jour locale
          populateTable(); // Actualise l'affichage du tableau HTML
        })
        .catch(error => {
          console.error("Erreur lors de l'ajout de la ligne avec le fichier :", error);
          alert("Erreur lors de l'ajout de la ligne.");
        });
      }
          
      // Gère l'événement de sélection de fichiers
      document.getElementById('fileInput').addEventListener('change', (event) => {
        const files = event.target.files;
        if (files.length > 0) {
          Array.from(files).forEach(file => {
            addRowWithFileName(file.name); // Ajoute une ligne pour chaque fichier sélectionné
          });
        }
      });

      document.getElementById("secondColumnListbox").addEventListener("change", function () {
        const selectedValue = this.value;
        if (selectedValue === "addTable") {
          handleAddTable(); // Ajoute un tableau si l'option correspondante est sélectionnée
        } else {
          selectedSecondValue = selectedValue; // Met à jour la valeur sélectionnée
          populateTable(); // Actualise l'affichage du tableau HTML
        }
      });
  
      document.getElementById("fileInputProject").addEventListener("change", async function (event) {
        const files = event.target.files;
        if (!files.length) {
          alert("Aucun fichier sélectionné.");
          return;
        }
      
        try {
          // Rafraîchir les enregistrements existants pour obtenir les derniers ID
          await refreshRecords();
      
          for (const file of files) {
            const workbook = await readXLSX(file);
            const feuilleFichiers = workbook.Sheets["Fichiers"];
            if (!feuilleFichiers) {
              alert(`La feuille 'Fichiers' est introuvable dans le fichier sélectionné (${file.name}).`);
              continue;
            }
      
            // Récupération du nom du projet
            const range = XLSX.utils.decode_range(feuilleFichiers["!ref"]);
            const projectNameCell = feuilleFichiers[XLSX.utils.encode_cell({ r: 0, c: 1 })];
            if (!projectNameCell || !projectNameCell.v) {
              alert(`Le nom du projet est introuvable dans le fichier ${file.name}.`);
              continue;
            }
      
            const projectName = projectNameCell.v.split(":").pop().trim();
            console.log("Nom du projet extrait :", projectName);
      
            // Vérifie si le projet existe déjà
            const projectExists = records.some((record) => record.NomProjet === projectName);
            if (!projectExists) {
              const maxIdLigne = records.reduce((max, record) => {
                const idLigne = parseInt(record.ID_Ligne, 10);
                return idLigne > max ? idLigne : max;
              }, 0);
      
              const newProjectId = maxIdLigne + 1;
              const projectRow = {
                NomProjet: projectName,
                NomEtage: "",
                Emetteur: "",
                Reference: "",
                Indice: "",
                Recu: "",
                DescriptionObservations: "",
                ID_Ligne: newProjectId.toString(),
              };
      
              await grist.docApi.applyUserActions([["AddRecord", "Fusion", null, projectRow]]);
              records.push(projectRow);
              console.log("Projet ajouté :", projectRow);
              await refreshRecords(); // Synchronise les enregistrements après ajout du projet
            }
      
            // Parcourir les tableaux et ajouter les lignes
            const tableNames = [];
            for (let r = 1; r <= range.e.r; r++) {
              const firstColCell = feuilleFichiers[XLSX.utils.encode_cell({ r, c: 0 })];
              const thirdColCell = feuilleFichiers[XLSX.utils.encode_cell({ r, c: 2 })];
      
              if (firstColCell && firstColCell.v === "Feuille" && thirdColCell && thirdColCell.v) {
                tableNames.push({ name: thirdColCell.v.trim(), row: r + 3 });
              }
            }
      
            console.log("Noms des tableaux extraits :", tableNames);
      
            for (const { name: tableName, row: startRow } of tableNames) {
              const tableRows = [];
      
              for (let r = startRow; r <= range.e.r; r++) {
                const firstColCell = feuilleFichiers[XLSX.utils.encode_cell({ r, c: 0 })];
                if (firstColCell && firstColCell.v === "*") break;
      
                const rowData = [];
                for (let c = 0; c < 5; c++) {
                  const cell = feuilleFichiers[XLSX.utils.encode_cell({ r, c })];
                  let cellValue = null;
      
                  if (cell) {
                    // Utiliser la valeur brute de la cellule, convertie en texte
                    cellValue = cell.w !== undefined ? cell.w : (cell.v !== undefined ? String(cell.v) : null);
                  }
      
                  rowData.push(cellValue === "" ? null : cellValue); // Conserve les valeurs vides comme null
                }
      
                // Remplir les cellules vides de la première colonne
                if (!rowData[0]) {
                  rowData[0] = tableRows.length > 0 ? tableRows[tableRows.length - 1][0] : null;
                }
      
                tableRows.push(rowData);
              }
      
              console.log(`Données pour le tableau "${tableName}" :`, tableRows);
      
              // Comparer et ajouter les nouvelles lignes
              const actions = [];
              for (const row of tableRows) {
                const transformedRow = {
                  NomProjet: projectName,
                  NomEtage: tableName,
                  Emetteur: row[0],
                  Reference: row[1],
                  Indice: row[2],
                  Recu: row[3],
                  DescriptionObservations: row[4],
                };
      
                // Vérification des doublons
                const isDuplicate = records.some((record) => {
                  return (
                    record.NomProjet === transformedRow.NomProjet &&
                    record.NomEtage === transformedRow.NomEtage &&
                    (record.Emetteur === transformedRow.Emetteur || (!record.Emetteur && !transformedRow.Emetteur)) &&
                    (record.Reference === transformedRow.Reference || (!record.Reference && !transformedRow.Reference)) &&
                    (record.Indice === transformedRow.Indice || (!record.Indice && !transformedRow.Indice)) &&
                    (record.Recu === transformedRow.Recu || (!record.Recu && !transformedRow.Recu)) &&
                    (record.DescriptionObservations === transformedRow.DescriptionObservations || (!record.DescriptionObservations && !transformedRow.DescriptionObservations))
                  );
                });
      
                if (!isDuplicate) {
                  const maxIdLigne = records.reduce((max, record) => {
                    const idLigne = parseInt(record.ID_Ligne, 10);
                    return idLigne > max ? idLigne : max;
                  }, 0);
      
                  const newRow = {
                    ...transformedRow,
                    ID_Ligne: (maxIdLigne + 1).toString(),
                  };
      
                  records.push(newRow); // Mise à jour locale
                  actions.push(["AddRecord", "Fusion", null, newRow]);
                } else {
                  console.log("Doublon détecté :", transformedRow);
                }
              }
      
              if (actions.length > 0) {
                await grist.docApi.applyUserActions(actions);
                console.log(`Tableau "${tableName}" ajouté avec ${actions.length} lignes.`);
                await refreshRecords(); // Synchronise après chaque tableau
              } else {
                console.log(
                  `Aucune nouvelle ligne ajoutée pour le tableau "${tableName}", tous les enregistrements sont déjà dans Grist.`
                );
              }
            }
          }
        } catch (error) {
          console.error("Erreur lors de l'importation :", error);
        }
      });

      // Fonction pour initialiser et mettre à jour la liste déroulante des projets
      function updateProjectDropdown() {
        const firstColumnDropdown = document.getElementById("firstColumnDropdown");
        const uniqueProjects = [...new Set(records.map(record => record.NomProjet))].sort();
      
        firstColumnDropdown.innerHTML = '<option value="">Select an option</option>';
        uniqueProjects.forEach((project) => {
          const option = document.createElement("option");
          option.value = project;
          option.text = project;
          firstColumnDropdown.appendChild(option);
        });
      
        // Ajouter les options pour ajouter ou insérer un projet
        const addProjectOption = document.createElement("option");
        addProjectOption.value = "Ajouter Projet";
        addProjectOption.text = "Ajouter Projet";
        firstColumnDropdown.appendChild(addProjectOption);
      
        const insertProjectOption = document.createElement("option");
        insertProjectOption.value = "Insérer Projet";
        insertProjectOption.text = "Insérer Projet";
        firstColumnDropdown.appendChild(insertProjectOption);
      }

      // Fonction pour lire un fichier Excel et retourner le workbook
      function readXLSX(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          
          reader.onload = (event) => {
            try {
              const data = new Uint8Array(event.target.result);
              const workbook = XLSX.read(data, { type: "array", raw: true });
              resolve(workbook);
            } catch (error) {
              reject(error);
            }
          };
      
          reader.onerror = (error) => {
            reject(error);
          };
      
          reader.readAsArrayBuffer(file);
        });
      }

      // Fonction pour rafraîchir les enregistrements depuis Grist
      async function refreshRecords() {
        try {
          // Récupère les enregistrements depuis la table "Fusion" dans Grist
          const receivedRecords = await grist.docApi.fetchTable("Fusion");
          
          if (!receivedRecords || !receivedRecords.id) {
            throw new Error("Données reçues dans un format inattendu.");
          }
      
          // Transforme les enregistrements pour l'usage local
          records = receivedRecords.id.map((id, index) => ({
            ID_Ligne: receivedRecords.ID_Ligne[index] || '',
            NomProjet: receivedRecords.NomProjet[index] || '',
            NomEtage: receivedRecords.NomEtage[index] || '',
            Emetteur: receivedRecords.Emetteur[index] || '',
            Reference: receivedRecords.Reference[index] || '',
            Indice: receivedRecords.Indice[index] || '',
            Recu: receivedRecords.Recu[index] || '',
            DescriptionObservations: receivedRecords.DescriptionObservations[index] || '',
          }));
      
          console.log("Enregistrements synchronisés :", records);
        } catch (error) {
          console.error("Erreur lors de la synchronisation des enregistrements :", error);
        }
      }

      // Fonction pour récupérer l'ID_Ligne le plus élevé dans Grist
      async function getMaxIdFromGrist() {
        await refreshRecords(); // Rafraîchir les données pour obtenir les derniers enregistrements
        const allIds = records
          .map(record => parseInt(record.ID_Ligne, 10))
          .filter(id => !isNaN(id)); // Filtrer uniquement les ID valides
        return Math.max(...allIds, 0); // Retourne le maximum ou 0 si aucun ID trouvé
      }

      // Fonction utilitaire pour calculer le prochain ID_Ligne localement
      function getNextIdLigne() {
        const allIds = records
          .map(record => parseInt(record.ID_Ligne, 10))
          .filter(id => !isNaN(id)); // Filtrer uniquement les ID valides
        return Math.max(...allIds, 0) + 1; // Retourne le prochain ID disponible
      }

      // Écouteur pour afficher le menu contextuel
      projectDropdown.addEventListener("contextmenu", (event) => {
        // Empêche le menu contextuel par défaut
        event.preventDefault();
      
        // Identifie l'élément cliqué
        const target = event.target;
      
        // Vérifie qu'il s'agit bien d'une option de projet
        if (target.tagName === "OPTION" && target.value !== "" && target.value !== "Ajouter Projet" && target.value !== "Insérer Projet") {
          selectedProjectForContextMenu = target.value;
      
          // Positionne et affiche le menu contextuel
          projectContextMenu.style.display = "block";
          projectContextMenu.style.left = `${event.pageX}px`;
          projectContextMenu.style.top = `${event.pageY}px`;
        } else {
          // Cache le menu si ce n'est pas un projet
          projectContextMenu.style.display = "none";
        }
      });
      
      // Écouteur pour masquer le menu contextuel si on clique ailleurs
      document.addEventListener("click", () => {
        projectContextMenu.style.display = "none";
      });
      
      // Suppression du projet sélectionné via le menu contextuel
      document.getElementById("deleteProjectOption").addEventListener("click", async () => {
        if (!selectedProjectForContextMenu) return;
      
        const confirmation = confirm(`Êtes-vous sûr de vouloir supprimer le projet "${selectedProjectForContextMenu}" et toutes ses lignes associées ?`);
        if (!confirmation) return;
      
        try {
          // Filtrer les IDs des lignes associées à ce projet
          const rowsToDelete = records
            .filter(record => record.NomProjet === selectedProjectForContextMenu)
            .map(record => Number(record.ID_Ligne));
      
          if (rowsToDelete.length === 0) {
            alert("Aucune ligne trouvée pour ce projet.");
            return;
          }
      
          // Préparer les actions de suppression
          const actions = rowsToDelete.map(rowId => ["RemoveRecord", "Fusion", rowId]);
      
          // Appliquer les suppressions dans Grist
          await grist.docApi.applyUserActions(actions);
      
          // Mise à jour locale des données
          records = records.filter(record => record.NomProjet !== selectedProjectForContextMenu);
      
          // Mise à jour des listes déroulantes et du tableau
          updateProjectDropdown();
          populateSecondColumnListbox("");
      
          alert(`Le projet "${selectedProjectForContextMenu}" a été supprimé avec succès.`);
        } catch (error) {
          console.error("Erreur lors de la suppression du projet :", error);
          alert("Une erreur est survenue lors de la suppression du projet.");
        } finally {
          projectContextMenu.style.display = "none"; // Cache le menu contextuel après suppression
        }
      });

    </script>
  </body>
</html>
